{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 48, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Administrator/projet-app-dvf/app/api/search/route.js"],"sourcesContent":["import { Client } from 'pg';\r\nimport { NextResponse } from 'next/server';\r\n\r\nexport async function GET(request) {\r\n  const { searchParams } = new URL(request.url);\r\n  const lat = searchParams.get('lat');\r\n  const lng = searchParams.get('lng');\r\n  const radiusParam = searchParams.get('radius');\r\n  const radius = radiusParam ? parseInt(radiusParam, 10) : 500; // Rayon par défaut 500m\r\n\r\n  if (!lat || !lng) {\r\n    return NextResponse.json({ error: 'Coordonnées manquantes' }, { status: 400 });\r\n  }\r\n\r\n  // Connexion au VPS\r\n  const client = new Client({\r\n    connectionString: \"postgresql://postgres:Maison2026!@51.178.36.210:5432/postgres\",\r\n    ssl: false\r\n  });\r\n\r\n  try {\r\n    await client.connect();\r\n\r\n    // Requête optimisée (Groupée par vente)\r\n    const query = `\r\n      SELECT \r\n        id_mutation,\r\n        MAX(date_mutation) as date_mutation,\r\n        MAX(valeur_fonciere) as valeur_fonciere,\r\n        MAX(adresse_numero) as adresse_numero,\r\n        MAX(adresse_nom_voie) as adresse_nom_voie,\r\n        MAX(code_postal) as code_postal,\r\n        MAX(nom_commune) as nom_commune,\r\n        MAX(id_parcelle) as id_parcelle,\r\n        -- Si type_local est NULL mais qu'il y a du terrain, on l'appelle 'Terrain'\r\n        COALESCE(STRING_AGG(DISTINCT type_local, ', '), 'Terrain') as type_local,\r\n        SUM(surface_reelle_bati) as surface_reelle_bati, \r\n        MAX(surface_terrain) as surface_terrain,\r\n        MAX(latitude) as latitude,\r\n        MAX(longitude) as longitude\r\n      FROM transactions\r\n      WHERE ST_DWithin(\r\n        geom,\r\n        ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,\r\n        $3\r\n      )\r\n      AND (\r\n        type_local IN ('Maison', 'Appartement', 'Local industriel. commercial ou assimilé') \r\n        OR \r\n        (type_local IS NULL AND surface_terrain > 0)\r\n      ) \r\n      GROUP BY id_mutation\r\n      ORDER BY date_mutation DESC\r\n      LIMIT 100;\r\n    `;\r\n\r\n    const result = await client.query(query, [lng, lat, radius]);\r\n    await client.end();\r\n\r\n    return NextResponse.json(result.rows);\r\n\r\n  } catch (error) {\r\n    console.error('Erreur API:', error);\r\n    return NextResponse.json({ error: error.message }, { status: 500 });\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;AAEO,eAAe,IAAI,OAAO;IAC/B,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,MAAM,aAAa,GAAG,CAAC;IAC7B,MAAM,MAAM,aAAa,GAAG,CAAC;IAC7B,MAAM,cAAc,aAAa,GAAG,CAAC;IACrC,MAAM,SAAS,cAAc,SAAS,aAAa,MAAM,KAAK,wBAAwB;IAEtF,IAAI,CAAC,OAAO,CAAC,KAAK;QAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyB,GAAG;YAAE,QAAQ;QAAI;IAC9E;IAEA,mBAAmB;IACnB,MAAM,SAAS,IAAI,uJAAM,CAAC;QACxB,kBAAkB;QAClB,KAAK;IACP;IAEA,IAAI;QACF,MAAM,OAAO,OAAO;QAEpB,wCAAwC;QACxC,MAAM,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8Bf,CAAC;QAED,MAAM,SAAS,MAAM,OAAO,KAAK,CAAC,OAAO;YAAC;YAAK;YAAK;SAAO;QAC3D,MAAM,OAAO,GAAG;QAEhB,OAAO,gJAAY,CAAC,IAAI,CAAC,OAAO,IAAI;IAEtC,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,eAAe;QAC7B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,MAAM,OAAO;QAAC,GAAG;YAAE,QAAQ;QAAI;IACnE;AACF"}}]
}